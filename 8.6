//8.6

/*
2025년 8월 6일 세번째 스터디 - 그래프
https://leetcode.com/problems/find-center-of-star-graph/description/?envType=problem-list-v2&envId=graph
https://leetcode.com/problems/binary-tree-inorder-traversal/description/?envType=problem-list-v2&envId=tree
힙
https://leetcode.com/problem-list/heap-priority-queue/ 
그래프
https://leetcode.com/problem-list/graph/
트리
https://leetcode.com/problem-list/tree/
해시
https://leetcode.com/problem-list/hash-table/
힙 선정문제
https://leetcode.com/problems/last-stone-weight/description/?envType=problem-list-v2&envId=heap-priority-queue
*/


class Solution {
public:
    int findCenter(vector<vector<int>>& edges) {
        int a = edges[0][0];
        int b = edges[0][1];

        if(edges[1][0] == a  edges[1][1] == a){
            return a;
        }else if(edges[1][0] == b  edges[1][1] == b){
            return b;
        }

        return 0;
    }
};


/**
 
Definition for a binary tree node.
struct TreeNode {
int val;
TreeNode *left;
TreeNode *right;
TreeNode() : val(0), left(nullptr), right(nullptr) {}
TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
TreeNode(int x, TreeNode left, TreeNoderight) : val(x), left(left), right(right) {}
};*/
class Solution {
public:
    vector<int> nodeList;
    void inorder(TreeNode* start){
        if(!start){
            return;
        }
        inorder(start->left);
        nodeList.push_back(start->val);
        inorder(start->right);
    }
    vector<int> inorderTraversal(TreeNode* root){
        inorder(root);
        return nodeList;
    }
};
